<?php

/**
 * Copyright 2021 Nitric Technologies Pty Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace Nitric\Api;

use Exception;
use Nitric\Proto\Queue\V1\NitricTask;
use Nitric\Proto\Queue\V1\QueueClient as GrpcClient;
use Nitric\Proto\Queue\V1\QueueReceiveRequest;
use Nitric\Proto\Queue\V1\QueueReceiveResponse;
use Nitric\Proto\Queue\V1\QueueSendBatchRequest;
use Nitric\Proto\Queue\V1\QueueSendBatchResponse;
use Nitric\Proto\Queue\V1\QueueSendRequest;
use Nitric\Proto\Queue\V1\QueueCompleteRequest;

/**
 * Class QueueClient provides a client for the Nitric Queue Service.
 * @package Nitric\Api
 */
class QueueClient extends AbstractClient
{
    private GrpcClient $client;

    /**
     * QueueClient constructor.
     *
     * @param GrpcClient|null $client the autogenerated gRPC client object. Typically only injected for mocked testing.
     */
    public function __construct(GrpcClient $client = null)
    {
        parent::__construct();
        if ($client) {
            $this->client = $client;
        } else {
            $this->client = new GrpcClient($this->hostname, $this->opts);
        }
    }

    /**
     * Convert the API class representing a task to the protobuf class
     *
     * @param Task $task
     * @return NitricTask
     * @throws Exception
     */
    private static function taskToWire(Task $task): NitricTask
    {
        $ne = new NitricTask();
        $ne->setPayload(
            self::structFromClass($task->getPayload())
        );
        $ne->setPayloadType($task->getPayloadType());
        $ne->setId($task->getId());

        return $ne;
    }

    /**
     * Send a task to a queue, which can be received by other services.
     *
     * @param string $queue the name of the queue to publish to
     * @param Task $task        the task to push to the queue
     * @throws Exception
     */
    public function send(string $queue, Task $task)
    {
        $request = new QueueSendRequest();
        $request->setQueue($queue);

        $request->setTask(self::taskToWire($task));

        [$response, $status] = $this->client->Send($request)->wait();
        $this->okOrThrow($status);
    }

    /**
     * Send a collection of tasks to a queue, which can be received by other services.
     *
     * @param  string $queue the name of the queue to publish to
     * @param  Task[] $tasks     The tasks to push to the queue
     * @return FailedTask[] containing a list containing details of any messages that failed to publish.
     * @throws Exception
     */
    public function sendBatch(string $queue, array $tasks): array
    {
        $request = new QueueSendBatchRequest();
        $request->setQueue($queue);

        $nitricTasks = array_map(
            function (Task $task) {
                return self::taskToWire($task);
            },
            $tasks
        );

        $request->setTasks($nitricTasks);

        [$response, $status] = $this->client->SendBatch($request)->wait();
        $this->okOrThrow($status);
        // Add type hint to the response object
        $response = (fn ($r): QueueSendBatchResponse => $r)($response);

        $failed = array_map(
            function (\Nitric\Proto\Queue\V1\FailedTask $t) {
                $task = new Task();
                $task->setId($t->getTask()->getId());
                $task->setPayloadType($t->getTask()->getPayloadType());
                $task->setPayload(AbstractClient::classFromStruct($t->getTask()->getPayload()));

                $failedTask = new FailedTask();
                $failedTask->setMessage($t->getMessage());
                $failedTask->setTask($task);
                return $failedTask;
            },
            [...$response->getFailedTasks()]
        );

        return $failed;
    }

    /**
     * Pop 1 or more items from the specified queue up to the depth limit.
     *
     * Received Tasks are leased for a limited period of time, where they may be worked on.
     * Once complete or failed they must be completed using the request specific leaseId.
     *
     * If the lease on a task expires before it is completed or the lease is extended the task will be
     * returned to the queue for reprocessing or forwarded to a dead-letter queue if retries have been exceeded.
     *
     * @param  string $queue Nitric name for the queue.
     *                       This will be automatically resolved to the provider specific identifier.
     * @param  int    $depth The maximum number of queue items to return. Default: 1, Min: 1.
     * @return Task[] Queue items popped from the queue.
     * @throws Exception
     */
    public function receive(string $queue, int $depth = 1): array
    {
        if ($depth < 1) {
            $depth = 1;
        }
        $request = new QueueReceiveRequest();
        $request->setQueue($queue);
        $request->setDepth($depth);

        [$response, $status] = $this->client->Receive($request)->wait();
        $this->okOrThrow($status);
        $response = (fn ($r): QueueReceiveResponse => $r)($response);


        return array_map(
            function (NitricTask $i) {
                return new Task(
                    payload: AbstractClient::classFromStruct($i->getPayload()),
                    payloadType: $i->getPayloadType(),
                    id: $i->getId(),
                    leaseId: $i->getLeaseId()
                );
            },
            [...$response->getTasks()]
        );
    }

    /**
     * Mark a task as complete, removing it from the queue to prevent reprocessing.
     *
     * @param string $queue the task came from
     * @param string $leaseId for the task, provided when receiving the task
     */
    public function complete(string $queue, string $leaseId)
    {
        $request = new QueueCompleteRequest();

        $request->setQueue($queue);
        $request->setLeaseId($leaseId);

        [$response, $status] = $this->client->Complete($request);
        $this->okOrThrow($status);
    }
}
